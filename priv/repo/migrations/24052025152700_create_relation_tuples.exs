defmodule SigilLock.Repo.Migrations.CreateRelationsTuples do
  use Ecto.Migration

  def change do
    create table(:relation_tuples, primary_key: false) do
      # Define the primary key as UUID, auto-generated by the database
      add :id, :binary_id, primary_key: true

      # Foreign key linking to the tenants table.
      # Assumes tenants table uses :binary_id for its primary key.
      # `on_delete: :delete_all` ensures tuples are removed if a tenant is deleted.
      add :tenant_id, references(:tenants, type: :binary_id, on_delete: :delete_all), null: false

      # Object definition
      add :object_type, :string, size: 128, null: false
      add :object_id, :string, size: 255, null: false

      # Relation definition
      add :relation, :string, size: 128, null: false

      # Subject definition (Split representation)
      add :subject_user_id, :string, size: 255, null: true # Nullable
      add :subject_set_object_type, :string, size: 128, null: true # Nullable
      add :subject_set_object_id, :string, size: 255, null: true # Nullable
      add :subject_set_relation, :string, size: 128, null: true # Nullable

      # Only track insertion time
      timestamps(updated_at: false)

      # --- Constraints ---

      # CHECK constraint to ensure subject definition integrity.
      # Mirrors the logic from the SQL schema and the Ecto changeset validation.
      constraint :chk_subject_defined, type: :check, check: """
        (subject_user_id IS NOT NULL AND subject_set_object_type IS NULL AND subject_set_object_id IS NULL AND subject_set_relation IS NULL)
        OR
        (subject_user_id IS NULL AND subject_set_object_type IS NOT NULL AND subject_set_object_id IS NOT NULL AND subject_set_relation IS NOT NULL)
      """
    end

    # --- Indexes ---

    # Index 1: Primary lookup pattern for checking permissions on an object.
    create index(:relation_tuples, [:tenant_id, :object_type, :object_id, :relation], name: :idx_relation_tuples_object)

    # Index 2: Find all direct relations granted TO a specific user (Partial Index).
    create index(:relation_tuples, [:tenant_id, :subject_user_id], name: :idx_relation_tuples_user_subject, where: "subject_user_id IS NOT NULL")

    # Index 3: CRITICAL for recursive userset expansion (Partial Index).
    create index(:relation_tuples, [:tenant_id, :subject_set_object_type, :subject_set_object_id, :subject_set_relation], name: :idx_relation_tuples_userset_subject, where: "subject_set_object_type IS NOT NULL")

    # Index 4: General index on tenant_id (can sometimes be helpful).
    create index(:relation_tuples, [:tenant_id], name: :idx_relation_tuples_tenant_id)


    # --- Unique Constraints (Implemented as Unique Partial Indexes) ---

    # Constraint 2 (from SQL): Prevent duplicate tuples for user subjects.
    create unique_index(:relation_tuples, [:tenant_id, :object_type, :object_id, :relation, :subject_user_id],
      name: :uq_relation_tuples_user_subject,
      where: "subject_user_id IS NOT NULL"
    )

    # Constraint 3 (from SQL): Prevent duplicate tuples for userset subjects.
    create unique_index(:relation_tuples, [:tenant_id, :object_type, :object_id, :relation, :subject_set_object_type, :subject_set_object_id, :subject_set_relation],
      name: :uq_relation_tuples_userset_subject,
      where: "subject_set_object_type IS NOT NULL" # Checking one set field is sufficient due to chk_subject_defined
    )

  end
end
